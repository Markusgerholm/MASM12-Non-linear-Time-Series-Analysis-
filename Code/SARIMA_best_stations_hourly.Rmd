---
title: "SARIMA_best_stations_hourly"
output: html_document
---

---
title: "SARIMA_8regimes"
output: html_document
---
## Function for CCF with hourly lags instead of element wise lags
```{r}
plot_ccf_hourly_lags <- function(df_he,
                                 df_x,
                                 regimes = c("R1","R2","R3","R4","R5","R6","R7","R8"),
                                 time_col = "ts_utc",
                                 value_col = "Lufttemperatur",
                                 lag_max = 50) {

  library(dplyr)
  library(forecast)

  x_name <- deparse(substitute(df_x))

  # --- Prewhiten x on FULL x-series ---
  fit_x <- auto.arima(df_x[[value_col]])
  df_x <- df_x %>% mutate(res_x = as.numeric(residuals(fit_x)))

  # --- Build an hourly grid (no interpolation; just a time index) ---
  t_min <- max(min(df_he[[time_col]], na.rm = TRUE),
               min(df_x[[time_col]],  na.rm = TRUE))
  t_max <- min(max(df_he[[time_col]], na.rm = TRUE),
               max(df_x[[time_col]],  na.rm = TRUE))

  grid <- tibble(!!time_col := seq(from = t_min, to = t_max, by = "1 hour"))

  # --- Join onto the grid to enforce hourly spacing ---
  # (If some hours are missing in either df, they'll be NA — that's OK.)
  he_g <- grid %>%
    left_join(df_he %>% select(all_of(time_col), res_he = res, regime),
              by = time_col) %>%
    arrange(.data[[time_col]])

  x_g <- grid %>%
    left_join(df_x %>% select(all_of(time_col), res_x),
              by = time_col) %>%
    arrange(.data[[time_col]])

  # --- Loop regimes with masking ---
  for (reg in regimes) {

    # Keep full hourly series, but only keep he residuals when regime is active
    y_masked <- ifelse(he_g$regime == reg, he_g$res_he, NA_real_)

    r <- ccf(x_g$res_x,
             y_masked,
             lag.max = lag_max,
             na.action = na.pass,
             plot = FALSE)

    pos <- r$lag >= 0

    # Effective n varies by lag because of NA masking and missing hours.
    # Use a conservative CI based on "available paired obs at lag 0".
    n0 <- sum(complete.cases(x_g$res_x, y_masked))
    ci <- if (n0 > 0) 1.96 / sqrt(n0) else NA_real_

    plot(r$lag[pos], r$acf[pos], type = "h",
         xlab = "Lag (hours)",
         ylab = "CCF",
         main = paste("CCF –", reg, "(", x_name, " prewhitened; hourly grid)"))

    abline(h = 0)
    if (!is.na(ci)) abline(h = c(-ci, ci), lty = 2)
  }

  invisible(list(fit_x = fit_x))
}

```


## Loading data

```{r}
setwd("..")
source("Code/read_data.r")
```

```{r}
library(zoo)
library(forecast)
library(ggplot2)
library(dplyr)
```

```{r}
helsingborg_2024_2025 <- helsingborg %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
nidingen_2024_2025 <- nidingen %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
hörby_2024_2025 <- hörby %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
falsterbo_2024_2025 <- falsterbo %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
skillinge_2024_2025 <- skillinge %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
ullared_2024_2025 <- ullared %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
ljungby_2024_2025 <- ljungby %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
hästveda_2024_2025 <- hästveda %>%
  filter(
    ts_utc >= as.POSIXct("2024-01-01 00:00:00", tz = "UTC"),
    ts_utc <= as.POSIXct("2025-08-31 23:59:59", tz = "UTC")
  )
```

## "Stationary" period

```{r}
start <- 3200
end <- 5900
df_he <- helsingborg_2024_2025[start:end, ] # center
df_ni <- nidingen_2024_2025[start:end, ] # north west
df_fa <- falsterbo_2024_2025[start:end, ] # south
df_hä <- hästveda_2024_2025[start:end, ] # east north east
df_lj <- ljungby_2024_2025[start:end, ] # north east
df_ul <- ullared_2024_2025[start:end, ] # north
df_sk <- skillinge_2024_2025[start:end, ] # south east
df_hö <- hörby_2024_2025[start:end, ] # east
```

## Training and testing split

```{r}
h <- 500
freq <- 24
# full series from your dataframe
y_all <- ts(helsingborg_2024_2025$Lufttemperatur, frequency = 24)

# convert row indices to ts "time" values
t_start <- 1 + (start - 1) / freq
t_end   <- 1 + (end   - 1) / freq
t_test_start <- 1 + (end) / freq          # row end + 1
t_test_end   <- 1 + (end + h - 1) / freq  # row end + h

# train/test as ts
y_train <- window(y_all, start = t_start, end = t_end)
y_test  <- window(y_all, start = t_test_start, end = t_test_end)

# additional test set roughly 6 months forward in time

gap <- 4000  

t_test1_start <- t_test_start + gap / freq
t_test1_end   <- t_test1_start + (h - 1) / freq

y_test1 <- window(y_all, start = t_test1_start, end = t_test1_end)

```

## Fixed and non-fixed parameters in p/q polynomials

```{r}
p <- rep(0, 18)
p[1] <- NA
p[2] <- NA
p[11] <- 0
p[18] <- NA

q <- rep(0, 23)
q[2] <- NA
q[20] <- NA
q[23] <- NA
```

## Seasonal ARIMA model:

```{r}
fit <- Arima(y_train,
                 order = c(18,0,23),
                fixed = c(p,q,NA),
                 seasonal = c(0,1,1))
```

## Adding residuals to df

```{r}
df_he$res <- fit$residuals
```

## 8 wind regimes

```{r}
wind_regime4 <- function(wd, ws, rot = 45) {
  wd <- (wd - rot) %% 360
  out <- rep(NA_character_, length(wd))

  # Only assign R1–R4 when wind speed is not zero, when zero, set regime to R5
  idx <- !is.na(ws) & ws != 0 & !is.na(wd)
 
  out[!is.na(ws) & ws == 0] <- "R0"
  out[idx & wd >   0 & wd <=  90] <- "R1"
  out[idx & wd >  90 & wd <= 180] <- "R2"
  out[idx & wd > 180 & wd <= 270] <- "R3"
  out[idx & wd > 270 & wd <  360] <- "R4"
  out[idx & wd == 0]              <- "R4"

  factor(out, levels = c("R0","R1","R2","R3","R4"))

}
wind_regime8 <- function(wd, ws, rot = 45) {
  wd <- (wd - rot) %% 360
  out <- rep(NA_character_, length(wd))

  # Only assign R1–R4 when wind speed is not zero, when zero, set regime to R5
  idx <- !is.na(ws) & ws != 0 & !is.na(wd)
 
  out[!is.na(ws) & ws == 0] <- "R0"
  out[idx & wd >   0 & wd <=  45] <- "R1"
  out[idx & wd >  45 & wd <= 90] <- "R2"
  out[idx & wd >  90 & wd <= 135] <- "R3"
  out[idx & wd >  135 & wd <= 180] <- "R4"
  out[idx & wd > 180 & wd <= 225] <- "R5"
  out[idx & wd > 225 & wd <  270] <- "R6"
  out[idx & wd > 270 & wd <  315] <- "R7"
  out[idx & wd > 315 & wd <  360] <- "R8"
  out[idx & wd == 0]              <- "R8"

  factor(out, levels = c("R0","R1","R2", "R3","R4","R5", "R6", "R7", "R8"))
}

df_he$regime <- wind_regime4(df_he$Vindriktning, df_he$Vindhastighet, rot = 45)
```

## Add danish weather station

```{r}
setwd("..")
source("Code/DenmarkFunctions.r")
```

```{r}
# Get available parameters for the station
params <- c("temp_dry","wind_dir","wind_speed")

start_time <- format(as.POSIXct(df_he$ts_utc[1], tz = "UTC"),
       "%Y-%m-%dT%H:%M:%SZ")
end_time <- format(as.POSIXct(df_he$ts_utc[nrow(df_he)], tz = "UTC"),
       "%Y-%m-%dT%H:%M:%SZ")
```

## Loading wanted stations
```{r}
stations <- c(
  kb = "06180", # Kobenhavn lufthavn
  ro = "06170", # Roskilde Lufthavn
  gn = "06049", # Gniben
  sl = "06073", # Sletterhage Fyr
  an = "06079"  # Anholt
)

df_list <- vector("list", length(stations))
names(df_list) <- names(stations)

missing_list <- vector("list", length(stations))
names(missing_list) <- names(stations)

for (nm in names(stations)) {
  station_id <- stations[[nm]]

  observations <- get_observations_for_station(
    station_id = station_id,
    parameters = params,
    start_dt   = start_time,
    end_dt     = end_time,
    limit      = 20000
  )

  full_seq <- seq(
    from = min(observations$observed),
    to   = max(observations$observed),
    by   = "10 min"
  )

  missing_times <- full_seq[!full_seq %in% observations$observed]
  missing_list[[nm]] <- missing_times

  df <- process_hourly_data(observations) %>%
    rename(
      Lufttemperatur = temp_dry,
      Vindriktning   = wind_dir,
      Vindhastighet  = wind_speed,
      ts_utc         = observed
    )

  fit_x <- forecast::auto.arima(df$Lufttemperatur)
  df$res <- residuals(fit_x)

  df_list[[nm]] <- df
}

# If you want:
df_kb <- df_list$kb
df_ro <- df_list$ro
df_gn <- df_list$gn
df_sl <- df_list$sl
df_an <- df_list$an
```

```{r}
table(df_he$regime, useNA = "ifany")
```

### R1
## Hästveda & Hörby - hourly lags

```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_hä,
  regimes = "R1"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_hö,
  regimes = "R1"
)
```

### R2
## Skillinge & Falsterbo - hourly lags
```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_sk,
  regimes = "R2"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_fa,
  regimes = "R2"
)
```

## Köbenhavn lufthavn & Roskilde lufthavn - hourly lag
```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_kb,
  regimes = "R2"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_ro,
  regimes = "R2"
)
```

### R3
## Roskilde lufthavn & Gniben - hourly lag
```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_ro,
  regimes = "R3"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_gn,
  regimes = "R3"
)
```

## Sletterhage fyr & Anholt - hourly lag
```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_sl,
  regimes = "R3"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_an,
  regimes = "R3"
)
```

### R4
## Nidingen & Ullared - hourly lag
```{r}
par(mfrow=c(1,2))
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_ni,
  regimes = "R4"
)
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_ul,
  regimes = "R4"
)
```

##Ljungby - hourly lag
```{r}
plot_ccf_hourly_lags(
  df_he = df_he,
  df_x  = df_lj,
  regimes = "R4"
)
```

## Function for obtaining positive lags greater than upper CI

```{r}
# Prewhiten x on the FULL x-series (once)
prewhiten_station <- function(df_x, value_col = "Lufttemperatur") {
  fit_x <- forecast::auto.arima(df_x[[value_col]])
  df_x$res_x <- as.numeric(residuals(fit_x))
  list(df = df_x, fit_x = fit_x)
}
# Hourly grid + join y and x on it, missing hours = NA
make_hourly_grid_join <- function(df_he, df_x, time_col = "ts_utc", value_col = "Lufttemperatur") {
  library(dplyr)

  t_min <- max(min(df_he[[time_col]], na.rm = TRUE),
               min(df_x[[time_col]],  na.rm = TRUE))
  t_max <- min(max(df_he[[time_col]], na.rm = TRUE),
               max(df_x[[time_col]],  na.rm = TRUE))

  grid <- tibble(!!time_col := seq(from = t_min, to = t_max, by = "1 hour"))

  grid %>%
    left_join(df_he %>% select(all_of(time_col), y = all_of(value_col), y_res = res, regime),
              by = time_col) %>%
    left_join(df_x  %>% select(all_of(time_col), x = all_of(value_col), x_res = res_x),
              by = time_col) %>%
    arrange(.data[[time_col]])
}


# Then extract significant positive lags or significantly large lags within a regime
get_ccf_lags_hourly <- function(df_he, df_x_pw, reg,
                                time_col = "ts_utc",
                                value_col = "Lufttemperatur",
                                lag_max = 50,
                                top_k = 3,
                                choose = c("strongest","largest")) {

  library(dplyr)
  choose <- match.arg(choose)

  full <- make_hourly_grid_join(df_he, df_x_pw, time_col = time_col, value_col = value_col)

  xw <- full$x_res
  yw <- ifelse(full$regime == reg, full$y_res, NA_real_)  # mask non-regime hours

  r <- ccf(xw, yw, lag.max = lag_max, plot = FALSE, na.action = na.pass)

  # consider only lags >= 0 (same convention you used before)
  pos <- which(r$lag >= 0)
  lags <- as.integer(r$lag[pos])
  acfv <- as.numeric(r$acf[pos])

  # compute a lag-specific CI using available pairs at that lag (more correct with NAs/masking)
  n_lag <- sapply(lags, function(L) {
    x_shift <- dplyr::lag(xw, L)
    sum(complete.cases(x_shift, yw))
  })
  ci_lag <- 1.96 / sqrt(n_lag)

  sig <- which(abs(acfv) > ci_lag & is.finite(ci_lag))
  if (length(sig) == 0) return(integer(0))

  sig_lags <- lags[sig]
  sig_acf  <- acfv[sig]

  if (choose == "largest") {
    # pick the largest hour lags among significant
    sig_lags <- sort(unique(sig_lags), decreasing = TRUE)
    return(sig_lags[seq_len(min(top_k, length(sig_lags)))])
  } else {
    # pick the strongest (largest |ccf|)
    ord <- order(abs(sig_acf), decreasing = TRUE)
    sig_lags[ord][seq_len(min(top_k, length(sig_lags)))]
  }
}
```

## See which lags are significant, e.g R3

```{r}
df_ro_pw <- prewhiten_station(df_gn)
lags_ro_R3 <- get_ccf_lags_hourly(df_he, df_ro_pw, reg = "R3", lag_max = 50, top_k = 3, choose = "largest")
lags_ro_R3
```

## Function for lagging x based on top 3 significant lags
```{r}
make_lagged_xreg <- function(x, lags) {
  X <- sapply(lags, function(L) dplyr::lag(x, L))
  colnames(X) <- paste0("x_L", lags)
  as.matrix(X)
}
```

## Function for rmse and rolling prediction

```{r}
rmse <- function(e) sqrt(mean(e^2, na.rm = TRUE))

score_arimax_fixed <- function(y, X = NULL, initial = 200) {
  n <- length(y)
  if (n <= initial + 1) return(NA_real_)

  # Fit ONCE on the initial window
  if (is.null(X)) {
    fit0 <- forecast::auto.arima(y[1:initial])
  } else {
    X0 <- X[1:initial, , drop = FALSE]
    fit0 <- forecast::auto.arima(y[1:initial], xreg = X0)
  }

  errs <- numeric(0)

  # Roll forward, but DO NOT refit; reuse fit0 parameters via model=
  for (t in initial:(n - 1)) {
    y_train <- y[1:t]
    y_test  <- y[t + 1]

    if (is.null(X)) {
      # apply same model structure/params to expanded data without re-estimation
      fit_t <- forecast::Arima(y_train, model = fit0)
      fc <- forecast::forecast(fit_t, h = 1)$mean[1]
    } else {
      X_train <- X[1:t, , drop = FALSE]
      X_test  <- X[t + 1, , drop = FALSE]

      fit_t <- forecast::Arima(y_train, xreg = X_train, model = fit0)
      fc <- forecast::forecast(fit_t, xreg = X_test, h = 1)$mean[1]
    }

    errs <- c(errs, y_test - fc)
  }

  rmse(errs)
}

```

## Function for ranking stations

```{r}
rank_stations_by_ccf_lags_hourly <- function(df_he, station_list, reg,
                                             time_col = "ts_utc",
                                             value_col = "Lufttemperatur",
                                             lag_max = 50,
                                             top_k = 3,
                                             choose = c("strongest","largest"),
                                             initial = 200) {

  library(dplyr)
  library(tidyr)

  choose <- match.arg(choose)

  res <- lapply(names(station_list), function(nm) {
    df_x <- station_list[[nm]]

    # lags in HOURS from masked-hourly CCF
    lags <- get_ccf_lags_hourly(df_he, df_x, reg = reg,
                                time_col = time_col, value_col = value_col,
                                lag_max = lag_max, top_k = top_k, choose = choose)

    # build hourly joined frame for fitting
    full <- make_hourly_grid_join(df_he, df_x, time_col = time_col, value_col = value_col)

    # subset to regime hours for modeling y
    full_reg <- full %>% filter(regime == reg)

    if (length(lags) == 0) {
      # baseline on regime hours only
      y0 <- full_reg$y %>% as.numeric()
      y0 <- y0[!is.na(y0)]
      if (length(y0) <= initial + 5) {
        return(data.frame(station = nm, n = length(y0), lags = "none",
                          rmse_base = NA_real_, rmse_arimax = NA_real_, improvement = NA_real_))
      }
      base <- score_arimax_fixed(y0, X = NULL, initial = min(initial, length(y0) - 2))
      return(data.frame(station = nm, n = length(y0), lags = "none",
                        rmse_base = base, rmse_arimax = NA_real_, improvement = NA_real_))
    }

    # lagged x on FULL HOURLY GRID (correct hourly meaning)
    X_full <- make_lagged_xreg(full$x, lags)

    # take the same regime rows from X_full
    X_reg <- X_full[full$regime == reg, , drop = FALSE]
    y_reg <- full$y[full$regime == reg]

    # keep complete cases (drops missing hours and lag-induced NA)
    keep <- complete.cases(y_reg, X_reg)
    y2 <- as.numeric(y_reg[keep])
    X2 <- X_reg[keep, , drop = FALSE]

    if (length(y2) <= initial + 5) {
      return(data.frame(station = nm, n = length(y2), lags = paste(lags, collapse = ","),
                        rmse_base = NA_real_, rmse_arimax = NA_real_, improvement = NA_real_))
    }

    # baseline should be computed on SAME y2 sample for fair comparison
    base <- score_arimax_fixed(y2, X = NULL, initial = min(initial, length(y2) - 2))
    r    <- score_arimax_fixed(y2, X = X2,   initial = min(initial, length(y2) - 2))

    data.frame(
      station = nm,
      n = length(y2),
      lags = paste(lags, collapse = ","),
      rmse_base = base,
      rmse_arimax = r,
      improvement = base - r
    )
  })

  bind_rows(res) %>% arrange(desc(improvement))
}
```

## R1
```{r}
df_hä_pw <- prewhiten_station(df_hä)
df_hö_pw <- prewhiten_station(df_hö)

stations_R1 <- list(
  hä = df_hä_pw,
  hö = df_hö_pw
)
rank_R1 <- rank_stations_by_ccf_lags_hourly(df_he, stations_R1, reg = "R1",
                                     lag_max = 50, top_k = 3, choose = "strongest", initial = 400)
rank_R1
```

## R2
```{r}
df_sk_pw <- prewhiten_station(df_sk)
df_fa_pw <- prewhiten_station(df_fa)
df_kb_pw <- prewhiten_station(df_kb)
df_ro_pw <- prewhiten_station(df_ro)

stations_R2 <- list(
  sk = df_sk_pw,
  fa = df_fa_pw,
  kb = df_kb_pw,
  ro = df_ro_pw
)
rank_R2 <- rank_stations_by_ccf_lags_hourly(df_he, stations_R2, reg = "R2",
                                     lag_max = 50, top_k = 3, choose = "strongest", initial = 500)
rank_R2
```
## R3
```{r}
stations_R3 <- list(
  ro = prewhiten_station(df_ro),
  gn = prewhiten_station(df_gn),
  sl = prewhiten_station(df_sl),
  an = prewhiten_station(df_an)
)
rank_R3 <- rank_stations_by_ccf_lags_hourly(df_he, stations_R3, reg = "R3",
                                     lag_max = 50, top_k = 3, choose = "strongest", initial = 500)
rank_R3
```

## R4
```{r}
df_ni_pw <- prewhiten_station(df_ni)
df_ul_pw <- prewhiten_station(df_ul)
df_lj_pw <- prewhiten_station(df_lj)

stations_R4 <- list(
  ni = df_ni_pw,
  ul = df_ul_pw,
  lj = df_lj_pw
)
rank_R4 <- rank_stations_by_ccf_lags_hourly(df_he, stations_R4, reg = "R4",
                                     lag_max = 50, top_k = 3, choose = "strongest", initial = 200)
rank_R4
```

## Winners based on RMSE and absolute value of correlations
# R1 - Hörby, lags: 0, 23, 47
# R2 - Köbenhavn lufthavn, lags: 0, 10, 47
# R3 - Sletterhage fyr, lags: 1, 12, 24
# R4 - Ullared, lags: 0, 1, 25

## Model orders and parameter estimates of each station after prewhitening -> used for predicting input in Kalman